<title>Hints for SRM 615, D1, 250-pointer (AmebaDiv1)</title>
<h3>Hints for SRM 615, D1, 250-pointer (AmebaDiv1)</h3>
<h3>James S. Plank</h3>
Tue Apr  8 18:16:17 EDT 2014
<br><a href=http://community.topcoder.com/stat?c=problem_statement&pm=13088&rd=15848>Problem Statement</a>.
<hr>

As far as D1-250's go, this was a pretty simple one.  
The only starting values for the amoeba are the values in <i>X</i>.  
However, you want to strip duplicates -- so create a set <b>initial</b>,
with all of the unique values in <i>X</i>.
That way, you have no duplicates.
<p>
Now, create another set, <b>final</b>, with potential final values.  
For each 
initial value in <b>initial</b>, simulate the 
the amoeba with that value.  Calculate the ending
value of the amoeba, and put it into <b>final</b>.  At the end, you can run through 
<b>initial</b> again, and count the number of elements that are not also in <b>final</b>.
That's the answer.
<p>
Let's look at examples:
<p>
<center>
<table border=3 cellpadding=2>
<tr>
<td align=center>Example</td>
<td align=center><i>X</i></td>
<td align=center><b>initial</b></td>
<td align=center><b>final</b></td>
<td align=center><b>Answer</b></td><tr>
<tr>
<td align=center>0</td>
<td align=center><i>{3, 2, 1}</i></td>
<td align=center><i>{1, 2, 3}</i></td>
<td align=center><i>{2, 4, 6}</i></td>
<td align=center><b>2</b></td><tr>
<tr>
<td align=center>1</td>
<td align=center><i>{2, 2, 2, 2, 2, 2, 4, 2, 2, 2}</i></td>
<td align=center><i>{2, 4}</b></td>
<td align=center><i>{8}</i></td>
<td align=center><b>2</b></td><tr>
<tr>
<td align=center>2</td>
<td align=center><i>{1, 2, 4, 8, 16, 32, 64, 128, 256, 1024, 2048}</i></td>
<td align=center><i>{1, 2, 4, 8, 16, 32, 64, 128, 256, 1024, 2048}</i></td>
<td align=center><i>{512, 4096}</i></td>
<td align=center><b>11</b></td><tr>
<tr>
<td align=center>3</td>
<td align=center><i>{854, 250, 934, 1000, 281, 250, 281, 467, 854, 562, 934, 1000, 854, 500, 562}</i></td>
<td align=center><i>{250, 281, 467, 500, 562, 854, 934, 1000}</i></td>
<td align=center><i>{1000, 1124, 1708, 1868, 2000}</i></td>
<td align=center><b>7</b></td><tr>
</table>
</center>
<p>

The running time complexity of this is <i>O(n<sup>2</sup>)</i>, where <i>n</i> is the
number of elements in <i>X</i>.  
Why is there no <i>log</i> term in that?  Lets break it down:
<UL>
<LI> Creating <b>initial</b> is <i>O(n*log(n))</i>.  The size of <b>initial</b> in the 
worst case is <i>n</i>.
<LI> Simulating an amoeba takes <i>O(n)</i> time, because you have to traverse all
of vector <i>X</i>.
<LI> Traversing <b>initial</b> is <i>O(<b>initial.size()</b>)</i>, which means that in the
worst case, it is <i>O(n)</i>.  
<LI> Therefore, simulating all of the amoebas in 
<b>initial</b> will take <i>O(n<sup>2</sup>)</i>.
<LI> Inserting each result into <b>final</b> is <i>O(log(n))</i>.
<LI> So, inserting all of the results into <b>final</b> is <i>O(n*log(n))</i>.
<LI> The dominant term here is <i>O(n<sup>2</sup>)</i>, so that is the running time.
</UL>
Fortunately, the maximum value of <i>n</i> is 200, so 
<i>O(n<sup>2</sup>)</i> is fast enough to complete within Topcoder's limits.
