<title>CS140 Midterm Exam - March 11, 2014 Answers and Grading</title>

<h2>CS140 Midterm Exam - March 11, 2014 Answers and Grading</h2>
James S. Plank
<hr><h2>Question 1: X Points</h2>

<b>Part A:</b> You start at 98, and look at successively higher indices mod 100: 98, 99, 0, 1.
<p>
<b>Part B:</b> Now, you start at 98, and add 0<sup>2</sup>, 1<sup>2</sup>, 2<sup>2</sup> and 
3<sup>2</sup>: 98, 99, 2, 5.
<p>
<b>Part C:</b> Now, you start at 98, and add 0*21, 1*21, 2*21 and 3*21:
98, 19, 40, 61.

<h3>Grading</h3>

1 point per answer, with the following caveats:
<UL>
<LI> <b>Part A:</b> To receive full credit on the 2nd, 3rd and 4th probes, they had to equal
the previous probe plus one, mod 100.
<LI> <b>Part A:</b> If you said 1 instead of 0, you got half credit.
<LI> <b>Part A:</b> If you forgot the mod 100 when you added one, you got half credit.
<LI> <b>Part B:</b> To get full credit, your answer for the first probe had to equal
the answer for the first probe in part A.
<LI> <b>Part B:</b> The other probes needed to be relative to the first probe.
<LI> <b>Part B:</b> If you forgot the mod 100, you got half credit.
<LI> <b>Part B:</b> On the third and fourth probes, if you were off by one, you got
half credit.
<LI> <b>Part C:</b> To get full credit, your answer for the first probe had to equal
the answer for the first probe in part A.
<LI> <b>Part C:</b> The other probes needed to be relative to the first probe.
<LI> <b>Part C:</b> If you forgot the mod 100, you got half credit.
<LI> <b>Part C:</b> On the second, third and fourtg probes, if you were off by one, you got
half credit.
</UL>

<p><center><table border=3><td><img src="q1.jpg" width=500></td></table></center><p>


<hr><h2>Question 2: 10 Points</h2>

Suppose that the file that implements the methods is <b>imp.cpp</b>, and the file
that uses the methods is <b>use.cpp</b>.  I need to have a header file that both 
<b>imp.cpp</b> and <b>use.cpp</b> include using "#include" statements.  
The header file will define the class.  In this definition, the methods will be 
"public" and the data will be "protected.  When I compile the program, I will 
run <b>g++</b> on the files <b>imp.cpp</b> and <b>use.cpp</b>.  I do not include the
header file in my compilation.


<h3>Grading</h3>

Three points per part.  You couldn't say "just use make."  

<p><center><table border=3><td><img src="q2.jpg" width=500></td></table></center><p>

<hr><h2>Question 3: 6 Points</h2>

When you erase an element from the beginning of a vector, the standard template library 
does the following (assume the vector is <b>v</b>):

<p><center><table border=3 cellpadding=3><td><pre>
for (i = 0; i < v.size()-1; i++) v[i] = v[i+1];
v.resize(v.size()-1);
</pre></td></table></center><p>

The running time complexity if that is linear in the size of the input, which makes this 
perform very poorly.  If you want to delete elements from the beginning of a data structure, 
you should use a deque, because the deletions take constant time rather than linear time, and
you can still access the elements like a vector.
Second in preference is a list, which also has constant time access, but now you have to use
iterators for access.

<h3>Grading</h3>

Three points for your explanation, and three points for the alternate data structure.
If you said list rather than deque, you lost a point, because a deque lets you access
elements like a vector.

<p><center><table border=3><td><img src="q3.jpg" width=500></td></table></center><p>

<hr><h2>Question 4: 9 Points</h2>

Straight from the lecture notes on lists:

<p><center><table border=3 cellpadding=3><td><pre>
main()
{
  list &lt;string&gt; l;
  list &lt;string&gt;::iterator lit;
  string s;
 
  while (getline(cin,s)) l.push_front(s);
  for (lit = l.begin(); lit != l.end(); lit++) cout &lt;&lt; *lit &lt;&lt; endl;
}
</pre></td></table></center><p>

You could create the list with <b>push_back()</b> and traverse it with a reverse iterator.
That works too.

<h3>Grading</h3>

This is one where you started with 9 points and we deducted for various things.

<p><center><table border=3><td><img src="q1.jpg" width=500></td></table></center><p>


<hr><h2>Question 5: 12 Points</h2>

This is a stringstream question:

<p><center><table border=3 cellpadding=3><td><pre>
main(int argc, char **argv)
{
  istringstream ss;
  double d1, d2;

  if (argc != 3) { cerr &lt;&lt; "Bad\n"; exit(1); }

  ss.clear();                 // This is optional.
  ss.str(argv[1]);
  if (!(ss &gt;&gt; d1)) { cerr &lt;&lt; "Bad\n"; exit(1); }
  
  ss.clear();
  ss.str(argv[2]);
  if (!(ss &gt;&gt; d2)) { cerr &lt;&lt; "Bad\n"; exit(1); }
  
  cout &lt;&lt; d1 + d2 &lt;&lt; endl;
}
</pre></td></table></center><p>

<h3>Grading</h3>

12 points.  Grading is like Question 4.

<p><center><table border=3><td><img src="q5.jpg" width=500></td></table></center><p>

<hr><h2>Question 6: 10 Points</h2>

<p><center><table border=3 cellpadding=3><td><pre>
string a(string &s)
{
  int i;
  string rv;

  rv = s;
  for (i = 0; i &lt; rv.size(); i++) {
    if (rv[i] &gt;= 'A' && rv[i] &lt;= 'Z') rv[i] += ('a'-'A');
  }
  return rv;
}
</pre></td></table></center><p>

<h3>Grading</h3>

10 points.  Grading is like Question 5.

<p><center><table border=3><td><img src="q6.jpg" width=500></td></table></center><p>

<hr><h2>Question 7: 15 Points</h2>

There are plenty of solutions.  My solution below takes each word and creates
a new word consisting of only the non-vowels.  If that word is of size zero, then
I simply use the original word.

<p><center><table border=3 cellpadding=3><td><pre>
class WordModifier {
  public:
    vector &lt;string&gt; ModList(vector &lt;string&gt; text);
};

vector &lt;string&gt; WordModifier::ModList(vector &lt;string&gt; text)
{
  vector &lt;string&gt; rv;
  string nw;
  string vowels;
  int i, j;
  char c;

  vowels = "aeiou";

  for (i = 0; i &lt; text.size(); i++) {
    nw = "";
    for (j = 0; j &lt; text[i].size(); j++) {
      c = text[i][j];
      if (vowels.find(c) == string::npos) nw.push_back(c);
    }
    if (nw.size() == 0) {
      rv.push_back(text[i]);
    } else {
      rv.push_back(nw);
    }
  }
  return rv;
}
</pre></td></table></center><p>

<h3>Grading</h3>

10 points.  Grading is like Question 6.
I took off for using <b>erase()</b>, not just because it makes for an <i>n<sup>2</sup></i>
algorithm, but your indices are typically messed up afterward.

<p><center><table border=3><td><img src="q7.jpg" width=500></td></table></center><p>

<hr><h2>Question 8: 12 Points</h2>

It's best to look at pictures -- a and b hold ints, c and d hold pointers to ints.  
After the first two statements, we have set a to 22 and c so that it points to a:

<p><center><table border=3><td><img src="Q8-1.jpg"></td></table></center><p>

In the next two statements, we set b to *c, which is 22.  Then we increment a by 10.
This is what the variables look like:

<p><center><table border=3><td><img src="Q8-2.jpg"></td></table></center><p>

So the first three <b>cout</b> statements are:

<p><center><table border=3 cellpadding=3><td><pre>
A: 32
B: 22
*C: 32
</pre></td></table></center><p>

Now, in the next four statements, we set c to a newly allocated four bytes, and then set
them to 88.  We set d to point to the memory to which c points, and then we set a to 
equal what *c, which is 88.  Here are the variables:

<p><center><table border=3><td><img src="Q8-3.jpg"></td></table></center><p>

Now, we set *c to 77, which changes those four bytes.  a remains at 88, so when we set
b to a, it is 88.  Then incrementing it by five yields 93.  Here is the final state of
the variables:

<p><center><table border=3><td><img src="Q8-4.jpg"></td></table></center><p>

The output is:

<p><center><table border=3 cellpadding=3><td><pre>
A: 88
B: 93
*C: 77
*D: 77
</pre></td></table></center><p>

<h3>Grading</h3>

1.7 points per line, except for the first, which was 1.8.  The last line had to equal
the penultimate line.

<p><center><table border=3><td><img src="q8.jpg" width=500></td></table></center><p>

