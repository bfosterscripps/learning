<UL>
<LI> <b>Topcoder 550-Point problem from SRM 355, Division 2</b>
<LI> James S. Plank
<LI> Tue Apr  9 12:12:53 EDT 2013
<LI> Definition from Topcoder: <a href=http://community.topcoder.com/stat?c=problem_statement&pm=7759&rd=10712>http://community.topcoder.com/stat?c=problem_statement&pm=7759&rd=10712</a>
<LI> Skeleton: <b><a href="NoEights.cpp">NoEights.cpp</a></b>
<LI> Main: <b><a href="NoEights-Main.cpp">NoEights-Main.cpp</a></b>
</UL>

As always, feel free to solve this problem on your own.  However, I 
would like you to think about the problem recursively.  That may not be
the most natural way for you to think about it, but it's good practice.
<p>
One of the keys to this problem is to turn <b>low</b> and <b>high</b>
into strings and work on the strings.  Here's how you can do it.  
<UL>
<LI> Turn <b>low</b> and <b>high</b>
into the strings <b>l</b> and <b>h</b>.
<LI> If the two strings differ in size, you can return instantly.  Think about it.
<LI> Otherwise, let's define a function <b>NE(l, h)</b>, where <b>l</b> and 
<b>h</b> are strings that are the same size.  We'll define <b>NE</b> as follows:
<p>
<UL>
<LI> If <b>l</b> and <b>h</b> are empty strings, then <b>NE(l, h)</b> equals zero.
<LI> Otherwise, let <b>l</b> be 
<i>l<sub>0</sub></i> + <b>l<sub>end</sub></b>, where <i>l<sub>0</sub></i> is the
first character of <b>l</b> and <b>l<sub>end</sub></b> is the rest of the characters.
Similarly, let 
<b>h</b> be 
<i>h<sub>0</sub></i> + <b>h<sub>end</sub></b>.  If <i>l<sub>0</sub></i> does not 
equal <i>h<sub>0</sub></i>, then <b>NE(l, h)</b> equals zero.
<LI> Otherwise, we know that 
<i>l<sub>0</sub></i> equals
<i>h<sub>0</sub></i>.  If <i>l<sub>0</sub></i> equals '8', then 
<b>NE(l, h)</b> equals
(1 + <b>NE(l<sub>end</sub>, h<sub>end</sub>)</b>).
<LI> Otherwise, <b>NE(l, h)</b> equals
<b>NE(l<sub>end</sub>, h<sub>end</sub>)</b>.
</UL>
<p>
</UL>

Go ahead and turn this definition into a recursive solution.  
<p>
I know you can do this with one <b>for</b> loop after you've created <b>l</b> 
and <b>h</b>.  However, I'd like you to structure it with recursion.  It's good
practice.
