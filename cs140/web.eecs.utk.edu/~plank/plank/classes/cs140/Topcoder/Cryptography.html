<title>Hints for SRM 499, D2, 250-pointer (Cryptography)</title>
<h3>Hints for SRM 499, D2, 250-pointer (Cryptography)</h3>
<h3>James S. Plank</h3>
Mon Mar 24 14:02:12 EDT 2014
<br><a href=http://community.topcoder.com/stat?c=problem_statement&pm=10814&rd=14159>Problem Statement</a>.
<hr>

First off, you need to figure out -- given a collection of numbers, which number do I increment
so that the product is increased by the largest amount?  It shouldn't be too hard to see that
you need to increment the smallest number.
<p>
If you want to prove that formally, you can.  Suppose you have a collection of numbers whose
product is <i>P</I>.  And suppose you have two numbers in the collection, <i>a</i> and <i>b</i>
such that <i>a &lt; b</i>.  
If you increment <i>a</i>, you change the product from <i>P</i> to <i>P(a+1)/a</i>.  
If you increment <i>b</i>, you change the product to <i>P(b+1)/b</i>.   Since
<i>a &lt; b</i>, 
we know that <i>(a+1)/a &gt; (b+1)/b</i>.  (If you are stuck on that, think about examples: 3/2 is definitely greater than 101/100, right?)  That means incrementing <i>a</i> will increase the 
factor by the greatest amount.
<p>
So, you need to find the minimum element and increment it.  I would do that by sorting the vector
and then incrementing the first element.  
<p>
Now how about calculating the product?  Since you are told that the product will be &le; 2<sup>62</sup>, you need to use a 64-bit integer.  In C++, this is a <b>long long</b>.  Calculate your product using that, and you're done.  
