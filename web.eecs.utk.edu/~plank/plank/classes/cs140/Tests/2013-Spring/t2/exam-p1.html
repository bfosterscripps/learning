<center>
<h3>2013 CS140 Final Exam</h3>
</center>
<UL>
<LI> Answer all questions.
<LI> Answer the questions on the answer sheets.
<LI> Do not answer questions on this exam.
<LI> Answer the questions on the <i>front</i> of the answer sheets, not the back.
<LI> When programming, you do not have to use <b>include</b> or <b>using</b> statements.
</UL>
<hr>
<font size=-1>
<h3>Question 1 - Basic Programming</h3>

<table><td valign=top><font size=-1>
Write the procedure <b>get_n_rev()</b> with the prototype to the right.
<p>

This procedure should return a vector composed of the last <i>n</i> 
lines of standard input in reverse order.  
If standard input has fewer than <i>n</i> lines, it should return all of the lines of 
standard input in reverse order.
<p>
You may use any data structure from the standard template library or from class
(I've included them all on the cheat sheet).  If standard input contains <i>l</i> 
lines, your program should run in <i>O(l)</i> time and <i>O(n)</i> space.  You will
lose half credit otherwise.
</td><td valign=top>
<center><table border=3 cellpadding=3><td><font size=-1><pre>
vector &lt;string&gt; get_n_rev(int n);
</pre></td></table></center></td></table>
<hr>
<h3>Question 2 - Basic Data Structures and Big-O</h3>

Tell me the running time of the following actions in terms of Big-O.
Use the answer sheet provided.  If the answer depends on the state of 
the data structure, give the worst-case.

<UL>
<LI> <b>A</b>: Finding an item in a AVL tree with <i>n</i> items.
<LI> <b>B</b>: Erasing the first item from a linked list with <i>n</i> items.
<LI> <b>C</b>: Performing a rotation on a node in an AVL tree with <i>n</i> items.
<LI> <b>D</b>: Deleting an item from an AVL tree with <i>n</i> items.
<LI> <b>E</b>: Finding an item in a regular binary search tree with <i>n</i> items.
<LI> <b>F</b>: Erasing the first item from a deque with <i>n</i> items.
<LI> <b>G</b>: Deleting an item from a set with <i>n</i> items.
<LI> <b>H</b>: Finding an item that is in a hash table with <i>n</i> items that had no collisions when the items were inserted.
<LI> <b>I</b>: Calling <b>Push()</b> on a stack with <i>n</i> items.
<LI> <b>J</b>: Inserting an item into a map with <i>n</i> items.
<LI> <b>K</b>: Erasing the first item from a vector with <i>n</i> items.
<LI> <b>L</b>: Finding an item in a linked list with <i>n</i> items.
</UL>

<hr>
<h3>Question 3 - Were you in this class?</h3>

Recall the Towers of Hanoi problem from class/lecture notes.  We had a 
class <b>Towers</b> that had a public method called <b>Make_Move()</b>
with the following prototypes:

<p><center><table border=3 cellpadding=3><td><font size=-1><pre>
void Make_Move(int from, int to);
</pre></td></table></center><p>

This double-checks the legality of moving a disk from tower <i>from</i> to tower <i>to</i>,
where <i>from</i> and <i>to</i> are 0, 1 or 2.  If the move is legal, it prints the move and
moves the top disk from tower <i>from</i> to tower <i>to</i>.

<p>
Write a procedure called <b>Solve()</b> with the following prototype:

<p><center><table border=3 cellpadding=3><td><font size=-1><pre>
void Solve(Towers *t, int from, int to, int npieces);
</pre></td></table></center><p>

This procedure should make the proper <b>Make_Move()</b> calls on the instance <i>t</i> 
to move the top <i>npieces</i> disks from tower <i>from</i> to tower <i>to</i>.

